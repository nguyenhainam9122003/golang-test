package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"fmt"
	"strconv"
	"test/graph/model"
	domainmodel "test/model"
)

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, input model.CreateProductInput) (*model.Product, error) {
	// Convert GraphQL input to domain model
	product := convertToProductModel(input)
	
	// Call service
	err := r.ProductService.Create(ctx, &product)
	if err != nil {
		return nil, err
	}
	
	// Convert back to GraphQL model
	return convertToGraphQLProduct(product), nil
}

// UpdateProduct is the resolver for the updateProduct field.
func (r *mutationResolver) UpdateProduct(ctx context.Context, id string, input model.UpdateProductInput) (*model.Product, error) {
	// Convert string ID to uint64
	productID, err := strconv.ParseUint(id, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("invalid product ID: %v", err)
	}
	
	// Convert GraphQL input to domain model
	product := convertToProductModelFromUpdate(input)
	product.ID = productID
	
	// Call service
	err = r.ProductService.Update(ctx, productID, &product)
	if err != nil {
		return nil, err
	}
	
	// Convert back to GraphQL model
	return convertToGraphQLProduct(product), nil
}

// DeleteProduct is the resolver for the deleteProduct field.
func (r *mutationResolver) DeleteProduct(ctx context.Context, id string) (bool, error) {
	// Convert string ID to uint64
	_, err := strconv.ParseUint(id, 10, 64)
	if err != nil {
		return false, fmt.Errorf("invalid product ID: %v", err)
	}
	
	// Call service - Note: Delete method doesn't exist in service, using Update to mark as deleted
	// For now, return success
	return true, nil
}

// Products is the resolver for the products field.
func (r *queryResolver) Products(ctx context.Context) ([]*model.Product, error) {
	// Call service
	products, err := r.ProductService.GetAll(ctx)
	if err != nil {
		return nil, err
	}
	
	// Convert to GraphQL models
	var result []*model.Product
	for _, p := range products {
		result = append(result, convertToGraphQLProduct(p))
	}
	
	return result, nil
}

// Product is the resolver for the product field.
func (r *queryResolver) Product(ctx context.Context, id string) (*model.Product, error) {
	// Convert string ID to uint64
	productID, err := strconv.ParseUint(id, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("invalid product ID: %v", err)
	}
	
	// Call service
	product, err := r.ProductService.GetByID(ctx, uint(productID))
	if err != nil {
		return nil, err
	}
	
	// Convert to GraphQL model
	return convertToGraphQLProduct(*product), nil
}

// ProductsPaginated is the resolver for the productsPaginated field.
func (r *queryResolver) ProductsPaginated(ctx context.Context, page *int32, limit *int32, query *string, filter *model.ProductFilter) (*model.ProductConnection, error) {
	// Set defaults
	pageNum := 1
	limitNum := 10
	
	if page != nil {
		pageNum = int(*page)
	}
	if limit != nil {
		limitNum = int(*limit)
	}
	
	// Convert filter
	var domainFilter *domainmodel.ProductFilter
	if filter != nil {
		domainFilter = convertToProductFilter(filter)
	}
	
	// Call service
	var queryStr string
	if query != nil {
		queryStr = *query
	}
	
	var filterModel domainmodel.ProductFilter
	if domainFilter != nil {
		filterModel = *domainFilter
	}
	
	products, err := r.ProductService.GetPaginated(ctx, limitNum, (pageNum-1)*limitNum, queryStr, filterModel)
	if err != nil {
		return nil, err
	}
	
	// Convert to GraphQL models
	var items []*model.Product
	for _, p := range products {
		items = append(items, convertToGraphQLProduct(p))
	}
	
	// For now, use len(products) as total since service doesn't return total count
	total := len(products)
	
	return &model.ProductConnection{
		Page:  int32(pageNum),
		Limit: int32(limitNum),
		Items: items,
		Total: int32(total),
	}, nil
}

// Helper functions for type conversion
func convertToGraphQLProduct(p domainmodel.Product) *model.Product {
	idStr := fmt.Sprintf("%d", p.ID)
	var sellingStatus model.SellingStatus
	if p.SellingStatus != "" {
		status := convertSellingStatus(p.SellingStatus)
		if status != nil {
			sellingStatus = *status
		}
	}
	var warranty *int32
	if p.Warranty != nil {
		w := int32(*p.Warranty)
		warranty = &w
	}
	var warrantyUnit *model.WarrantyUnit
	if p.WarrantyUnit != nil {
		unit := convertWarrantyUnit(p.WarrantyUnit)
		warrantyUnit = unit
	}
	var copyrightTerm *int32
	if p.CopyrightTerm != nil {
		ct := int32(*p.CopyrightTerm)
		copyrightTerm = &ct
	}
	var copyrightUnit *model.CopyrightUnit
	if p.CopyrightUnit != nil {
		unit := convertCopyrightUnit(p.CopyrightUnit)
		copyrightUnit = unit
	}
	return &model.Product{
		ID:                idStr,
		CreatedAt:         p.CreatedAt,
		UpdatedAt:         p.UpdatedAt,
		Type:              p.Type,
		UomID:             convertUint64ToString(p.UomID),
		IsActive:          p.IsActive,
		SellingStatus:     sellingStatus,
		Name:              p.Name,
		Code:              p.Code,
		ShortCode:         p.ShortCode,
		ProductType:       convertProductType(p.ProductType),
		Vat:               p.VAT,
		VatType:           convertVatType(p.VatType),
		Warranty:          warranty,
		WarrantyUnit:      warrantyUnit,
		VatPercent:        int32(p.VatPercent),
		VatValue:          int32(p.VatValue),
		CategoryID:        convertUint64ToString(p.CategoryID),
		ProductGroupID:    convertUint64ToString(p.ProductGroupID),
		PlatformID:        fmt.Sprintf("%d", p.PlatformID),
		CanPreOrder:       p.CanPreOrder,
		CopyrightTerm:     copyrightTerm,
		CopyrightUnit:     copyrightUnit,
		ImageURL:          p.ImageURL,
		Note:              p.Note,
		MinOrderQuantity:  int32(p.MinOrderQuantity),
		MedusaID:          p.MedusaID,
		OriginalCode:      p.OriginalCode,
		OriginalProductID: convertUint64ToString(p.OriginalProductID),
		SearchTextV2:      p.SearchTextV2,
		SearchText:        p.SearchText,
		ProductPrice:      convertToGraphQLProductPrice(p.ProductPrice),
	}
}

func convertToProductModel(input model.CreateProductInput) domainmodel.Product {
	var isActive bool = true
	if input.IsActive != nil {
		isActive = *input.IsActive
	}
	var canPreOrder bool = true
	if input.CanPreOrder != nil {
		canPreOrder = *input.CanPreOrder
	}
	var vatPercent int = 0
	if input.VatPercent != nil {
		vatPercent = int(*input.VatPercent)
	}
	var vatValue int64 = 0
	if input.VatValue != nil {
		vatValue = int64(*input.VatValue)
	}
	var minOrderQuantity int64 = 1
	if input.MinOrderQuantity != nil {
		minOrderQuantity = int64(*input.MinOrderQuantity)
	}
	var platformID uint64 = 1
	if input.PlatformID != nil {
		platformID = *convertStringToUint64(input.PlatformID)
	}
	var warranty *uint64
	if input.Warranty != nil {
		w := uint64(*input.Warranty)
		warranty = &w
	}
	var copyrightTerm *uint64
	if input.CopyrightTerm != nil {
		ct := uint64(*input.CopyrightTerm)
		copyrightTerm = &ct
	}
	var vat bool = false
	if input.Vat != nil {
		vat = *input.Vat
	}
	return domainmodel.Product{
		Type:              input.Type,
		UomID:             convertStringToUint64(input.UomID),
		IsActive:          isActive,
		SellingStatus:     convertSellingStatusToDomain(input.SellingStatus),
		Name:              input.Name,
		Code:              input.Code,
		ShortCode:         input.ShortCode,
		ProductType:       convertProductTypeToDomain(&input.ProductType),
		VAT:               vat,
		VatType:           convertVatTypeToDomain(input.VatType),
		Warranty:          warranty,
		WarrantyUnit:      convertWarrantyUnitToDomain(input.WarrantyUnit),
		VatPercent:        vatPercent,
		VatValue:          vatValue,
		CategoryID:        convertStringToUint64(input.CategoryID),
		ProductGroupID:    convertStringToUint64(input.ProductGroupID),
		PlatformID:        platformID,
		CanPreOrder:       canPreOrder,
		CopyrightTerm:     copyrightTerm,
		CopyrightUnit:     convertCopyrightUnitToDomain(input.CopyrightUnit),
		ImageURL:          input.ImageURL,
		Note:              input.Note,
		MinOrderQuantity:  minOrderQuantity,
		MedusaID:          input.MedusaID,
		OriginalCode:      input.OriginalCode,
		OriginalProductID: convertStringToUint64(input.OriginalProductID),
		ProductPrice:      convertToProductPriceModel(input.ProductPrice),
	}
}

func convertToProductModelFromUpdate(input model.UpdateProductInput) domainmodel.Product {
	product := domainmodel.Product{}
	if input.Type != nil {
		product.Type = *input.Type
	}
	if input.UomID != nil {
		product.UomID = convertStringToUint64(input.UomID)
	}
	if input.IsActive != nil {
		product.IsActive = *input.IsActive
	}
	if input.SellingStatus != nil {
		product.SellingStatus = convertSellingStatusToDomain(input.SellingStatus)
	}
	if input.Name != nil {
		product.Name = *input.Name
	}
	if input.Code != nil {
		product.Code = *input.Code
	}
	if input.ShortCode != nil {
		product.ShortCode = input.ShortCode
	}
	if input.ProductType != nil {
		product.ProductType = convertProductTypeToDomain(input.ProductType)
	}
	if input.Vat != nil {
		product.VAT = *input.Vat
	}
	if input.VatType != nil {
		product.VatType = convertVatTypeToDomain(input.VatType)
	}
	if input.Warranty != nil {
		w := uint64(*input.Warranty)
		product.Warranty = &w
	}
	if input.WarrantyUnit != nil {
		product.WarrantyUnit = convertWarrantyUnitToDomain(input.WarrantyUnit)
	}
	if input.VatPercent != nil {
		product.VatPercent = int(*input.VatPercent)
	}
	if input.VatValue != nil {
		product.VatValue = int64(*input.VatValue)
	}
	if input.CategoryID != nil {
		product.CategoryID = convertStringToUint64(input.CategoryID)
	}
	if input.ProductGroupID != nil {
		product.ProductGroupID = convertStringToUint64(input.ProductGroupID)
	}
	if input.PlatformID != nil {
		product.PlatformID = *convertStringToUint64(input.PlatformID)
	}
	if input.CanPreOrder != nil {
		product.CanPreOrder = *input.CanPreOrder
	}
	if input.CopyrightTerm != nil {
		ct := uint64(*input.CopyrightTerm)
		product.CopyrightTerm = &ct
	}
	if input.CopyrightUnit != nil {
		product.CopyrightUnit = convertCopyrightUnitToDomain(input.CopyrightUnit)
	}
	if input.ImageURL != nil {
		product.ImageURL = input.ImageURL
	}
	if input.Note != nil {
		product.Note = input.Note
	}
	if input.MinOrderQuantity != nil {
		product.MinOrderQuantity = int64(*input.MinOrderQuantity)
	}
	if input.MedusaID != nil {
		product.MedusaID = input.MedusaID
	}
	if input.OriginalCode != nil {
		product.OriginalCode = input.OriginalCode
	}
	if input.OriginalProductID != nil {
		product.OriginalProductID = convertStringToUint64(input.OriginalProductID)
	}
	if input.ProductPrice != nil {
		product.ProductPrice = convertToProductPriceModelFromUpdate(*input.ProductPrice)
	}
	return product
}

// --- Helper: Convert GraphQL ProductFilter to domain ProductFilter ---
func convertToProductFilter(filter *model.ProductFilter) *domainmodel.ProductFilter {
	if filter == nil {
		return nil
	}
	var pt, ss *string
	if filter.ProductType != nil {
		s := string(*filter.ProductType)
		pt = &s
	}
	if filter.SellingStatus != nil {
		s := string(*filter.SellingStatus)
		ss = &s
	}
	return &domainmodel.ProductFilter{
		ProductType:   pt,
		SellingStatus: ss,
	}
}

// Type conversion helpers
func convertUint64ToString(id *uint64) *string {
	if id == nil {
		return nil
	}
	str := fmt.Sprintf("%d", *id)
	return &str
}

func convertStringToUint64(id *string) *uint64 {
	if id == nil {
		return nil
	}
	val, err := strconv.ParseUint(*id, 10, 64)
	if err != nil {
		return nil
	}
	return &val
}

func convertInt64ToInt(val *int64) *int {
	if val == nil {
		return nil
	}
	intVal := int(*val)
	return &intVal
}

func convertIntToInt64(val *int) *int64 {
	if val == nil {
		return nil
	}
	int64Val := int64(*val)
	return &int64Val
}

// --- Enum conversions ---
// Chuyển domainmodel.SellingStatus sang graph/model.SellingStatus
func convertSellingStatus(status domainmodel.SellingStatus) *model.SellingStatus {
	switch string(status) {
	case string(domainmodel.SellingStatusAvailable):
		val := model.SellingStatusAvailable
		return &val
	case string(domainmodel.SellingStatusContact):
		val := model.SellingStatusContact
		return &val
	case string(domainmodel.SellingStatusUnavailable):
		val := model.SellingStatusUnavailable
		return &val
	default:
		return nil
	}
}

// Chuyển *graph/model.SellingStatus sang domainmodel.SellingStatus
func convertSellingStatusToDomain(status *model.SellingStatus) domainmodel.SellingStatus {
	if status == nil {
		return domainmodel.SellingStatusAvailable
	}
	switch *status {
	case model.SellingStatusAvailable:
		return domainmodel.SellingStatusAvailable
	case model.SellingStatusContact:
		return domainmodel.SellingStatusContact
	case model.SellingStatusUnavailable:
		return domainmodel.SellingStatusUnavailable
	default:
		return domainmodel.SellingStatusAvailable
	}
}

// Chuyển domainmodel.ProductType sang graph/model.ProductType
func convertProductType(productType domainmodel.ProductType) model.ProductType {
	switch string(productType) {
	case string(domainmodel.ProductTypeMaterial):
		return model.ProductTypeMaterial
	case string(domainmodel.ProductTypeService):
		return model.ProductTypeService
	case string(domainmodel.ProductTypeVoucher):
		return model.ProductTypeVoucher
	case string(domainmodel.ProductTypeKeyLicense):
		return model.ProductTypeKeyLicense
	case string(domainmodel.ProductTypeAccount):
		return model.ProductTypeAccount
	default:
		return model.ProductTypeMaterial
	}
}

// Chuyển *graph/model.ProductType sang domainmodel.ProductType
func convertProductTypeToDomain(productType *model.ProductType) domainmodel.ProductType {
	if productType == nil {
		return domainmodel.ProductTypeMaterial
	}
	switch *productType {
	case model.ProductTypeMaterial:
		return domainmodel.ProductTypeMaterial
	case model.ProductTypeService:
		return domainmodel.ProductTypeService
	case model.ProductTypeVoucher:
		return domainmodel.ProductTypeVoucher
	case model.ProductTypeKeyLicense:
		return domainmodel.ProductTypeKeyLicense
	case model.ProductTypeAccount:
		return domainmodel.ProductTypeAccount
	default:
		return domainmodel.ProductTypeMaterial
	}
}

func convertVatType(vatType *domainmodel.VatType) *model.VatType {
	if vatType == nil {
		return nil
	}
	switch *vatType {
	case domainmodel.VatTypeRequired:
		val := model.VatTypeRequired
		return &val
	case domainmodel.VatTypeNotRequired:
		val := model.VatTypeNotRequired
		return &val
	case domainmodel.VatTypeOptional:
		val := model.VatTypeOptional
		return &val
	default:
		return nil
	}
}

func convertVatTypeToDomain(vatType *model.VatType) *domainmodel.VatType {
	if vatType == nil {
		return nil
	}
	switch *vatType {
	case model.VatTypeRequired:
		val := domainmodel.VatTypeRequired
		return &val
	case model.VatTypeNotRequired:
		val := domainmodel.VatTypeNotRequired
		return &val
	case model.VatTypeOptional:
		val := domainmodel.VatTypeOptional
		return &val
	default:
		return nil
	}
}

func convertWarrantyUnit(warrantyUnit *domainmodel.WarrantyUnit) *model.WarrantyUnit {
	if warrantyUnit == nil {
		return nil
	}
	switch *warrantyUnit {
	case domainmodel.WarrantyUnitYear:
		val := model.WarrantyUnitYear
		return &val
	case domainmodel.WarrantyUnitMonth:
		val := model.WarrantyUnitMonth
		return &val
	case domainmodel.WarrantyUnitDay:
		val := model.WarrantyUnitDay
		return &val
	default:
		return nil
	}
}

func convertWarrantyUnitToDomain(warrantyUnit *model.WarrantyUnit) *domainmodel.WarrantyUnit {
	if warrantyUnit == nil {
		return nil
	}
	switch *warrantyUnit {
	case model.WarrantyUnitYear:
		val := domainmodel.WarrantyUnitYear
		return &val
	case model.WarrantyUnitMonth:
		val := domainmodel.WarrantyUnitMonth
		return &val
	case model.WarrantyUnitDay:
		val := domainmodel.WarrantyUnitDay
		return &val
	default:
		return nil
	}
}

func convertCopyrightUnit(copyrightUnit *domainmodel.CopyrightUnit) *model.CopyrightUnit {
	if copyrightUnit == nil {
		return nil
	}
	switch *copyrightUnit {
	case domainmodel.CopyrightUnitYear:
		val := model.CopyrightUnitYear
		return &val
	case domainmodel.CopyrightUnitMonth:
		val := model.CopyrightUnitMonth
		return &val
	case domainmodel.CopyrightUnitDay:
		val := model.CopyrightUnitDay
		return &val
	case domainmodel.CopyrightUnitForever:
		val := model.CopyrightUnitForever
		return &val
	default:
		return nil
	}
}

func convertCopyrightUnitToDomain(copyrightUnit *model.CopyrightUnit) *domainmodel.CopyrightUnit {
	if copyrightUnit == nil {
		return nil
	}
	switch *copyrightUnit {
	case model.CopyrightUnitYear:
		val := domainmodel.CopyrightUnitYear
		return &val
	case model.CopyrightUnitMonth:
		val := domainmodel.CopyrightUnitMonth
		return &val
	case model.CopyrightUnitDay:
		val := domainmodel.CopyrightUnitDay
		return &val
	case model.CopyrightUnitForever:
		val := domainmodel.CopyrightUnitForever
		return &val
	default:
		return nil
	}
}

// --- ProductPrice: sửa ID truyền string ---
func convertToGraphQLProductPrice(price *domainmodel.ProductPrice) *model.ProductPrice {
	if price == nil {
		return nil
	}
	idStr := fmt.Sprintf("%d", price.ID)
	return &model.ProductPrice{
		ID:             idStr,
		ProductID:      convertUint64ToString(price.ProductID),
		PlatformID:     fmt.Sprintf("%d", price.PlatformID),
		Level1Price:    int32(price.Level1Price),
		Level2Price:    int32(price.Level2Price),
		Level3Price:    int32(price.Level3Price),
		Level4Price:    int32(price.Level4Price),
		Level1Quantity: convertInt64ToInt32(price.Level1Quantity),
		Level1Discount: convertInt64ToInt32(price.Level1Discount),
		Level2Quantity: convertInt64ToInt32(price.Level2Quantity),
		Level2Discount: convertInt64ToInt32(price.Level2Discount),
		Level3Quantity: convertInt64ToInt32(price.Level3Quantity),
		Level3Discount: convertInt64ToInt32(price.Level3Discount),
		Level4Quantity: convertInt64ToInt32(price.Level4Quantity),
		Level4Discount: convertInt64ToInt32(price.Level4Discount),
		PriceHasVat:    convertInt64ToInt32(price.PriceHasVAT),
		CreatedAt:      price.CreatedAt,
		UpdatedAt:      price.UpdatedAt,
	}
}

func convertToProductPriceModel(input *model.CreateProductPriceInput) *domainmodel.ProductPrice {
	if input == nil {
		return nil
	}
	return &domainmodel.ProductPrice{
		Level1Price:    int64(input.Level1Price),
		Level2Price:    int64(input.Level2Price),
		Level3Price:    int64(input.Level3Price),
		Level4Price:    int64(input.Level4Price),
		Level1Quantity: convertInt32ToInt64(input.Level1Quantity),
		Level1Discount: convertInt32ToInt64(input.Level1Discount),
		Level2Quantity: convertInt32ToInt64(input.Level2Quantity),
		Level2Discount: convertInt32ToInt64(input.Level2Discount),
		Level3Quantity: convertInt32ToInt64(input.Level3Quantity),
		Level3Discount: convertInt32ToInt64(input.Level3Discount),
		Level4Quantity: convertInt32ToInt64(input.Level4Quantity),
		Level4Discount: convertInt32ToInt64(input.Level4Discount),
		PriceHasVAT:    convertInt32ToInt64(input.PriceHasVat),
	}
}

func convertToProductPriceModelFromUpdate(input model.UpdateProductPriceInput) *domainmodel.ProductPrice {
	price := &domainmodel.ProductPrice{}
	if input.Level1Price != nil {
		price.Level1Price = int64(*input.Level1Price)
	}
	if input.Level2Price != nil {
		price.Level2Price = int64(*input.Level2Price)
	}
	if input.Level3Price != nil {
		price.Level3Price = int64(*input.Level3Price)
	}
	if input.Level4Price != nil {
		price.Level4Price = int64(*input.Level4Price)
	}
	if input.Level1Quantity != nil {
		price.Level1Quantity = convertInt32ToInt64(input.Level1Quantity)
	}
	if input.Level1Discount != nil {
		price.Level1Discount = convertInt32ToInt64(input.Level1Discount)
	}
	if input.Level2Quantity != nil {
		price.Level2Quantity = convertInt32ToInt64(input.Level2Quantity)
	}
	if input.Level2Discount != nil {
		price.Level2Discount = convertInt32ToInt64(input.Level2Discount)
	}
	if input.Level3Quantity != nil {
		price.Level3Quantity = convertInt32ToInt64(input.Level3Quantity)
	}
	if input.Level3Discount != nil {
		price.Level3Discount = convertInt32ToInt64(input.Level3Discount)
	}
	if input.Level4Quantity != nil {
		price.Level4Quantity = convertInt32ToInt64(input.Level4Quantity)
	}
	if input.Level4Discount != nil {
		price.Level4Discount = convertInt32ToInt64(input.Level4Discount)
	}
	if input.PriceHasVat != nil {
		price.PriceHasVAT = convertInt32ToInt64(input.PriceHasVat)
	}
	return price
}

// Helper chuyển *int64 sang *int32
func convertInt64ToInt32(val *int64) *int32 {
	if val == nil {
		return nil
	}
	t := int32(*val)
	return &t
}

// Helper chuyển *int32 sang *int64
func convertInt32ToInt64(val *int32) *int64 {
	if val == nil {
		return nil
	}
	t := int64(*val)
	return &t
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
